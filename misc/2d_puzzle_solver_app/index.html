<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Puzzle Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #555;
        }

        input[type="number"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            width: 100px;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .grid {
            display: grid;
            gap: 2px;
            background: #333;
            padding: 2px;
            border-radius: 5px;
        }

        .cell {
            width: 50px;
            height: 50px;
            background: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .cell:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .cell.has-number {
            background: #ffeaa7;
            color: #2d3436;
        }

        .cell.path {
            background: #74b9ff;
            color: white;
        }

        .cell.path-start {
            background: #00b894;
            color: white;
        }

        .cell.path-end {
            background: #e17055;
            color: white;
        }

        .cell.path-0 {
            background: #74b9ff;
        }

        .cell.path-1 {
            background: #fd79a8;
        }

        .cell.path-2 {
            background: #fdcb6e;
        }

        .cell.path-3 {
            background: #6c5ce7;
        }

        .cell.path-4 {
            background: #55efc4;
        }

        .cell.path-5 {
            background: #a29bfe;
        }

        .message {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: 600;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .instructions {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #2196f3;
        }

        .instructions h2 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
            color: #555;
        }

        .instructions li {
            margin: 5px 0;
        }

        input[type="number"].cell-input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            background: transparent;
            padding: 0;
        }

        input[type="number"].cell-input:focus {
            outline: 2px solid #667eea;
            background: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§© 2D Puzzle Solver</h1>
        
        <div class="instructions">
            <h2>How to Use:</h2>
            <ul>
                <li>Enter the grid size (n) and click "Create Grid"</li>
                <li>Click on any cell to enter a number (click again to edit or clear)</li>
                <li>Enter the target sum</li>
                <li>Click "Solve" to find paths connecting pairs that sum to the target</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="gridSize">Grid Size (n):</label>
                <input type="number" id="gridSize" min="2" max="20" value="5">
                <button id="createGridBtn">Create Grid</button>
            </div>
            <div class="control-group">
                <label for="targetSum">Target Sum:</label>
                <input type="number" id="targetSum" value="5" step="0.1">
            </div>
            <button id="solveBtn" disabled>Solve</button>
            <button id="clearBtn" disabled>Clear All</button>
        </div>

        <div class="grid-container">
            <div id="grid" class="grid"></div>
        </div>

        <div id="message" class="message" style="display: none;"></div>
    </div>

    <script>
        let gridSize = 5;
        let numberCells = new Map(); // Map of "x,y" -> value
        let solution = null;

        // Create grid
        document.getElementById('createGridBtn').addEventListener('click', () => {
            gridSize = parseInt(document.getElementById('gridSize').value);
            if (gridSize < 2 || gridSize > 20) {
                showMessage('Grid size must be between 2 and 20', 'error');
                return;
            }
            createGrid();
            numberCells.clear();
            solution = null;
            document.getElementById('solveBtn').disabled = false;
            document.getElementById('clearBtn').disabled = false;
            hideMessage();
        });

        // Clear all numbers
        document.getElementById('clearBtn').addEventListener('click', () => {
            numberCells.clear();
            solution = null;
            createGrid();
            hideMessage();
        });

        // Solve puzzle
        document.getElementById('solveBtn').addEventListener('click', async () => {
            const targetSum = parseFloat(document.getElementById('targetSum').value);
            if (numberCells.size === 0) {
                showMessage('Please enter at least one number in the grid', 'error');
                return;
            }
            if (numberCells.size % 2 !== 0) {
                showMessage('Number of cells with numbers must be even', 'error');
                return;
            }

            const numberCellsList = Array.from(numberCells.entries()).map(([key, value]) => {
                const [x, y] = key.split(',').map(Number);
                return [x, y, value];
            });

            // Disable solve button while solving
            const solveBtn = document.getElementById('solveBtn');
            solveBtn.disabled = true;
            solveBtn.textContent = 'Solving...';
            
            try {
                solution = await solve2DPuzzle(gridSize, numberCellsList, targetSum);
                displaySolution();
            } catch (error) {
                console.error('Solve error:', error);
                showMessage('Error solving puzzle: ' + error.message, 'error');
            } finally {
                solveBtn.disabled = false;
                solveBtn.textContent = 'Solve';
            }
        });

        function createGrid() {
            const grid = document.getElementById('grid');
            grid.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;
            grid.innerHTML = '';

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    const key = `${x},${y}`;
                    if (numberCells.has(key)) {
                        cell.textContent = numberCells.get(key);
                        cell.classList.add('has-number');
                    }

                    cell.addEventListener('click', () => handleCellClick(x, y, cell));
                    grid.appendChild(cell);
                }
            }
        }

        function handleCellClick(x, y, cell) {
            const key = `${x},${y}`;
            
            if (numberCells.has(key)) {
                // Edit existing number
                const currentValue = numberCells.get(key);
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'cell-input';
                input.value = currentValue;
                input.step = '0.1';
                
                cell.innerHTML = '';
                cell.appendChild(input);
                input.focus();
                input.select();

                const finishEdit = () => {
                    const value = parseFloat(input.value);
                    if (isNaN(value) || value <= 0) {
                        numberCells.delete(key);
                        cell.textContent = '';
                        cell.classList.remove('has-number');
                    } else {
                        numberCells.set(key, value);
                        cell.textContent = value;
                        cell.classList.add('has-number');
                    }
                    solution = null;
                    hideMessage();
                };

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        input.blur();
                    }
                });
            } else {
                // Add new number
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'cell-input';
                input.step = '0.1';
                input.placeholder = '0';
                
                cell.innerHTML = '';
                cell.appendChild(input);
                input.focus();

                const finishEdit = () => {
                    const value = parseFloat(input.value);
                    if (isNaN(value) || value <= 0) {
                        cell.textContent = '';
                        cell.classList.remove('has-number');
                    } else {
                        numberCells.set(key, value);
                        cell.textContent = value;
                        cell.classList.add('has-number');
                    }
                    solution = null;
                    hideMessage();
                };

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        input.blur();
                    }
                });
            }
        }

        function displaySolution() {
            if (!solution || solution.length === 0) {
                showMessage('No solution found', 'error');
                createGrid();
                return;
            }

            showMessage(`Solution found with ${solution.length} path(s)!`, 'success');
            
            // Create a map of cells to path indices
            const cellToPath = new Map();
            solution.forEach((path, pathIdx) => {
                path.forEach(([x, y]) => {
                    const key = `${x},${y}`;
                    if (!cellToPath.has(key)) {
                        cellToPath.set(key, []);
                    }
                    cellToPath.get(key).push(pathIdx);
                });
            });

            // Update grid display
            const grid = document.getElementById('grid');
            const cells = grid.querySelectorAll('.cell');
            
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const key = `${x},${y}`;
                
                // Remove all path classes
                cell.className = 'cell';
                cell.classList.remove('path', 'path-start', 'path-end', 'path-0', 'path-1', 'path-2', 'path-3', 'path-4', 'path-5');
                
                if (cellToPath.has(key)) {
                    const pathIndices = cellToPath.get(key);
                    const pathIdx = pathIndices[0];
                    const path = solution[pathIdx];
                    
                    // Check if it's start or end of this specific path
                    const isStart = path[0][0] === x && path[0][1] === y;
                    const isEnd = path[path.length - 1][0] === x && path[path.length - 1][1] === y;
                    
                    if (isStart && isEnd) {
                        // Both start and end (single cell path - shouldn't happen normally)
                        cell.classList.add('path-start');
                    } else if (isStart) {
                        cell.classList.add('path-start');
                    } else if (isEnd) {
                        cell.classList.add('path-end');
                    } else {
                        cell.classList.add('path', `path-${pathIdx % 6}`);
                    }
                }
                
                // Keep number display
                if (numberCells.has(key)) {
                    cell.textContent = numberCells.get(key);
                    cell.classList.add('has-number');
                }
            });
        }

        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type}`;
            message.style.display = 'block';
        }

        function hideMessage() {
            document.getElementById('message').style.display = 'none';
        }

        // Puzzle solver functions
        // 
        // This supports two modes:
        // 1. Backend API mode: Calls a Python backend running OR-Tools CP-SAT (recommended for accuracy)
        // 2. JavaScript fallback: Uses constraint-based backtracking (works offline but may be slower)
        
        const USE_BACKEND_API = true; // Set to false to use JavaScript solver only
        const BACKEND_URL = 'http://localhost:5000/solve'; // Backend API URL
        
        async function solve2DPuzzle(n, numberCellsList, targetSum) {
            // Try backend API first if enabled
            if (USE_BACKEND_API) {
                try {
                    const result = await solveWithBackendAPI(n, numberCellsList, targetSum);
                    if (result !== null) {
                        return result;
                    }
                } catch (error) {
                    console.warn('Backend API failed, falling back to JavaScript solver:', error);
                    // Don't show error message - just silently fall back
                }
            }
            
            // Fallback to JavaScript solver
            return solve2DPuzzleConstraint(n, numberCellsList, targetSum);
        }
        
        // Call Python backend API with OR-Tools CP-SAT
        async function solveWithBackendAPI(n, numberCellsList, targetSum) {
            const response = await fetch(BACKEND_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    n: n,
                    number_cells: numberCellsList,
                    target_sum: targetSum
                })
            });
            
            if (!response.ok) {
                throw new Error(`Backend API error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            if (!data.solution || data.solution.length === 0) {
                return [];
            }
            
            // Convert backend response to expected format: list of paths
            // Backend returns list of paths, each path is list of [x, y] coordinates
            return data.solution;
        }

        // Constraint-based solver that models CP-SAT approach
        function solve2DPuzzleConstraint(n, numberCellsList, targetSum) {
            const tolerance = 1e-9;
            
            // Create grid and collect terminals
            const grid = Array(n).fill(null).map(() => Array(n).fill(0));
            const terminals = [];
            const terminalSet = new Set();
            
            numberCellsList.forEach(([x, y, value]) => {
                grid[x][y] = value;
                terminals.push([[x, y], value]);
                terminalSet.add(`${x},${y}`);
            });
            
            const m = terminals.length;
            if (m % 2 !== 0) {
                return [];
            }
            
            // Build candidate pairs whose values sum to target_sum
            const candidates = [];
            for (let i = 0; i < m; i++) {
                for (let j = i + 1; j < m; j++) {
                    if (Math.abs(terminals[i][1] + terminals[j][1] - targetSum) < tolerance) {
                        candidates.push([i, j]);
                    }
                }
            }
            
            if (candidates.length === 0) {
                return [];
            }
            
            // Quick feasibility check
            const incidentCount = new Array(m).fill(0);
            candidates.forEach(([i, j]) => {
                incidentCount[i]++;
                incidentCount[j]++;
            });
            if (incidentCount.some(count => count === 0)) {
                return [];
            }
            
            // Precompute adjacency
            function neighbors(rc) {
                const [r, c] = rc;
                const out = [];
                if (r > 0) out.push([r - 1, c]);
                if (r + 1 < n) out.push([r + 1, c]);
                if (c > 0) out.push([r, c - 1]);
                if (c + 1 < n) out.push([r, c + 1]);
                return out;
            }
            
            const allCells = [];
            for (let r = 0; r < n; r++) {
                for (let c = 0; c < n; c++) {
                    allCells.push([r, c]);
                }
            }
            const emptyCells = allCells.filter(rc => !terminalSet.has(`${rc[0]},${rc[1]}`));
            
            // Use constraint-based search with perfect matching + flow constraints
            return solveWithConstraints(n, grid, terminals, terminalSet, candidates, emptyCells, allCells, neighbors);
        }
        
        // Constraint-based solver using perfect matching + flow search
        function solveWithConstraints(n, grid, terminals, terminalSet, candidates, emptyCells, allCells, neighbors) {
            const m = terminals.length;
            
            // First, find all perfect matchings (each terminal used exactly once)
            const matchings = generatePerfectMatchings(candidates, m);
            
            // Sort by heuristic (shorter total distance)
            matchings.sort((a, b) => {
                const distA = a.reduce((sum, [i, j]) => {
                    const s1 = terminals[i][0];
                    const s2 = terminals[j][0];
                    return sum + Math.abs(s1[0] - s2[0]) + Math.abs(s1[1] - s2[1]);
                }, 0);
                const distB = b.reduce((sum, [i, j]) => {
                    const s1 = terminals[i][0];
                    const s2 = terminals[j][0];
                    return sum + Math.abs(s1[0] - s2[0]) + Math.abs(s1[1] - s2[1]);
                }, 0);
                return distA - distB;
            });
            
            // For each matching, try to find paths that satisfy flow and disjointness constraints
            // Limit to first 100 matchings to prevent excessive computation
            const maxMatchingsToTry = Math.min(100, matchings.length);
            for (let i = 0; i < maxMatchingsToTry; i++) {
                const result = findPathsForMatching(n, grid, terminals, terminalSet, matchings[i], emptyCells, allCells, neighbors);
                if (result !== null) {
                    return result;
                }
            }
            
            return [];
        }
        
        // Generate all perfect matchings (each terminal appears exactly once)
        function generatePerfectMatchings(candidates, numTerminals) {
            const matchings = [];
            const used = new Set();
            
            function backtrack(currentMatching, remainingCandidates) {
                if (used.size === numTerminals) {
                    matchings.push([...currentMatching]);
                    return;
                }
                
                for (let i = 0; i < remainingCandidates.length; i++) {
                    const [idx1, idx2] = remainingCandidates[i];
                    
                    // Check if both terminals are unused
                    if (!used.has(idx1) && !used.has(idx2)) {
                        used.add(idx1);
                        used.add(idx2);
                        currentMatching.push([idx1, idx2]);
                        
                        backtrack(currentMatching, remainingCandidates.slice(i + 1));
                        
                        currentMatching.pop();
                        used.delete(idx1);
                        used.delete(idx2);
                    }
                }
            }
            
            backtrack([], candidates);
            return matchings;
        }
        
        // Find paths for a given matching using flow-based search with backtracking
        function findPathsForMatching(n, grid, terminals, terminalSet, matching, emptyCells, allCells, neighbors) {
            let backtrackCount = 0;
            const maxBacktrackCalls = 100000; // Safety limit to prevent infinite loops
            
            // Use backtracking to try multiple paths for each pair
            function backtrackPaths(pairIndex, usedCells, currentPaths) {
                backtrackCount++;
                if (backtrackCount > maxBacktrackCalls) {
                    return null; // Safety limit reached
                }
                
                if (pairIndex >= matching.length) {
                    return currentPaths; // Found a complete solution
                }
                
                const [idx1, idx2] = matching[pairIndex];
                const [s, valS] = terminals[idx1];
                const [t, valT] = terminals[idx2];
                
                // Try multiple paths for this pair (up to a reasonable limit)
                // This allows backtracking if a path doesn't lead to a solution
                // Limit to 10 paths per pair to prevent excessive exploration
                const pathsForPair = findAllPathsWithConstraints(n, grid, s, t, usedCells, terminalSet, neighbors, 10);
                
                for (const path of pathsForPair) {
                    // Create new used cells set with this path's intermediate cells
                    const newUsedCells = new Set(usedCells);
                    for (let i = 1; i < path.length - 1; i++) {
                        newUsedCells.add(`${path[i][0]},${path[i][1]}`);
                    }
                    
                    // Recursively try to complete the solution
                    const result = backtrackPaths(pairIndex + 1, newUsedCells, [...currentPaths, path]);
                    if (result !== null) {
                        return result;
                    }
                }
                
                return null; // No valid path combination found for this matching
            }
            
            return backtrackPaths(0, new Set(), []);
        }
        
        // Find all possible paths between start and end (for backtracking)
        function findAllPathsWithConstraints(n, grid, start, end, usedCells, terminalSet, neighbors, maxPaths = 20) {
            const paths = [];
            const tolerance = 1e-9;
            
            if (start[0] === end[0] && start[1] === end[1]) {
                return [[start]];
            }
            
            // Use BFS to find multiple paths, with limits to prevent infinite loops
            // Use a priority queue approach: track paths by length
            const queue = [[start, [start], new Set([`${start[0]},${start[1]}`])]];
            const maxQueueSize = 1000; // Limit queue size to prevent memory issues
            let iterations = 0;
            const maxIterations = 10000; // Safety limit
            
            while (queue.length > 0 && paths.length < maxPaths && iterations < maxIterations) {
                iterations++;
                
                // Sort by path length to try shorter paths first (only when queue gets large)
                if (queue.length > 100) {
                    queue.sort((a, b) => a[1].length - b[1].length);
                }
                
                const [current, path, visitedInPath] = queue.shift();
                
                for (const next of neighbors(current)) {
                    if (paths.length >= maxPaths) break; // Found enough paths
                    
                    const nextKey = `${next[0]},${next[1]}`;
                    
                    // Check if goal
                    if (next[0] === end[0] && next[1] === end[1]) {
                        paths.push([...path, next]);
                        if (paths.length >= maxPaths) break; // Found enough paths
                        continue;
                    }
                    
                    // Skip if already visited in this path (prevents cycles within a path)
                    if (visitedInPath.has(nextKey)) {
                        continue;
                    }
                    
                    // Skip if used by another path (vertex disjointness constraint)
                    if (usedCells.has(nextKey)) {
                        continue;
                    }
                    
                    // Skip if it's a number cell (but not start/end) - flow constraint
                    const cellValue = grid[next[0]][next[1]];
                    const isNumberCell = cellValue > 0 || Math.abs(cellValue) > tolerance;
                    if (isNumberCell && terminalSet.has(nextKey)) {
                        continue;
                    }
                    
                    // Limit queue size to prevent memory explosion
                    if (queue.length < maxQueueSize) {
                        const newVisited = new Set(visitedInPath);
                        newVisited.add(nextKey);
                        queue.push([next, [...path, next], newVisited]);
                    }
                }
                
                if (paths.length >= maxPaths) break; // Found enough paths, exit while loop
            }
            
            // Sort paths by length (shortest first)
            paths.sort((a, b) => a.length - b.length);
            return paths;
        }
        
        function manhattanDist(a, b) {
            return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
        }
        
        // Keep the backtracking solver as fallback
        function solve2DPuzzleBacktrack(n, numberCellsList, targetSum) {
            // Use tolerance for floating point comparison (matching notebook)
            const tolerance = 1e-9;
            
            // Create a grid to mark number cells
            const grid = Array(n).fill(null).map(() => Array(n).fill(0));
            const numberPositions = new Map();
            
            numberCellsList.forEach(([x, y, value]) => {
                grid[x][y] = value;
                numberPositions.set(`${x},${y}`, value);
            });
            
            // Find all valid pairs that sum to target_sum
            const validPairs = [];
            const cellsList = Array.from(numberPositions.entries());
            
            for (let i = 0; i < cellsList.length; i++) {
                for (let j = i + 1; j < cellsList.length; j++) {
                    const [key1, val1] = cellsList[i];
                    const [key2, val2] = cellsList[j];
                    const [x1, y1] = key1.split(',').map(Number);
                    const [x2, y2] = key2.split(',').map(Number);
                    
                    if (Math.abs(val1 + val2 - targetSum) < tolerance) { // Float comparison with tolerance
                        validPairs.push([[x1, y1], [x2, y2]]);
                    }
                }
            }
            
            if (validPairs.length === 0) {
                return [];
            }
            
            // Quick feasibility check: every terminal must have at least one candidate partner
            const allNumberCells = Array.from(numberPositions.keys()).map(key => {
                const [x, y] = key.split(',').map(Number);
                return [x, y];
            });
            const incidentCount = new Array(allNumberCells.length).fill(0);
            validPairs.forEach(pair => {
                const [start, end] = pair;
                const startIdx = allNumberCells.findIndex(([x, y]) => x === start[0] && y === start[1]);
                const endIdx = allNumberCells.findIndex(([x, y]) => x === end[0] && y === end[1]);
                if (startIdx !== -1) incidentCount[startIdx]++;
                if (endIdx !== -1) incidentCount[endIdx]++;
            });
            if (incidentCount.some(count => count === 0)) {
                return [];
            }
            
            // Try to find a valid combination of pairs and paths
            return findValidSolution(n, grid, numberPositions, validPairs, targetSum);
        }

        function findPathBFS(n, grid, start, end, usedCells) {
            const tolerance = 1e-9;
            
            if (start[0] === end[0] && start[1] === end[1]) {
                return [start];
            }
            
            const queue = [[start, [start]]];
            const visited = new Set();
            visited.add(`${start[0]},${start[1]}`);
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // right, left, down, up
            
            while (queue.length > 0) {
                const [[x, y], path] = queue.shift();
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Check bounds
                    if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
                        continue;
                    }
                    
                    // Check if it's the destination
                    if (nx === end[0] && ny === end[1]) {
                        return [...path, [nx, ny]];
                    }
                    
                    const nextKey = `${nx},${ny}`;
                    
                    // Skip if already visited in this search
                    if (visited.has(nextKey)) {
                        continue;
                    }
                    
                    // Skip if used by another path
                    if (usedCells.has(nextKey)) {
                        continue;
                    }
                    
                    // Skip if it's a number cell (but not start or end)
                    // Handle float numbers: check if value > 0 or abs(value) > tolerance
                    const cellValue = grid[nx][ny];
                    const isNumberCell = cellValue > 0 || Math.abs(cellValue) > tolerance;
                    if (isNumberCell && (nx !== start[0] || ny !== start[1]) && (nx !== end[0] || ny !== end[1])) {
                        continue;
                    }
                    
                    visited.add(nextKey);
                    queue.push([[nx, ny], [...path, [nx, ny]]]);
                }
            }
            
            return null;
        }

        function findValidSolution(n, grid, numberPositions, validPairs, targetSum) {
            const allNumberCells = Array.from(numberPositions.keys()).map(key => {
                const [x, y] = key.split(',').map(Number);
                return [x, y];
            });
            
            // Heuristic: prioritize pairs with shorter Manhattan distances
            function manhattanDistance([x1, y1], [x2, y2]) {
                return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            }
            
            // Create a fast lookup map for valid pairs (optimization)
            const pairMap = new Map();
            validPairs.forEach(pair => {
                const [start, end] = pair;
                const key1 = `${start[0]},${start[1]}`;
                const key2 = `${end[0]},${end[1]}`;
                if (!pairMap.has(key1)) pairMap.set(key1, new Set());
                if (!pairMap.has(key2)) pairMap.set(key2, new Set());
                pairMap.get(key1).add(key2);
                pairMap.get(key2).add(key1);
            });
            
            // Fast check if two cells form a valid pair
            function isValidPair(cell1, cell2) {
                const key1 = `${cell1[0]},${cell1[1]}`;
                const key2 = `${cell2[0]},${cell2[1]}`;
                return pairMap.has(key1) && pairMap.get(key1).has(key2);
            }
            
            // Get the actual pair from validPairs
            function getPair(cell1, cell2) {
                return validPairs.find(p => {
                    const p0 = p[0];
                    const p1 = p[1];
                    return (p0[0] === cell1[0] && p0[1] === cell1[1] && 
                            p1[0] === cell2[0] && p1[1] === cell2[1]) ||
                           (p0[0] === cell2[0] && p0[1] === cell2[1] && 
                            p1[0] === cell1[0] && p1[1] === cell1[1]);
                });
            }
            
            // Find all possible paths between start and end (not just the first one)
            // Returns paths sorted by length (shortest first) for better pruning
            function findAllPathsBFS(n, grid, start, end, usedCells, maxPaths = 20) {
                const tolerance = 1e-9;
                const paths = [];
                
                if (start[0] === end[0] && start[1] === end[1]) {
                    return [[start]];
                }
                
                // Use a priority queue (by path length) to try shorter paths first
                const queue = [[start, [start], new Set([`${start[0]},${start[1]}`]), 0]];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                
                while (queue.length > 0 && paths.length < maxPaths) {
                    // Sort queue by path length to prioritize shorter paths
                    queue.sort((a, b) => a[3] - b[3]);
                    const [[x, y], path, visited, pathLen] = queue.shift();
                    
                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        // Check bounds
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
                            continue;
                        }
                        
                        const nextKey = `${nx},${ny}`;
                        
                        // Check if it's the destination
                        if (nx === end[0] && ny === end[1]) {
                            const fullPath = [...path, [nx, ny]];
                            paths.push(fullPath);
                            if (paths.length >= maxPaths) break;
                            continue;
                        }
                        
                        // Skip if already visited in this path
                        if (visited.has(nextKey)) {
                            continue;
                        }
                        
                        // Skip if used by another path
                        if (usedCells.has(nextKey)) {
                            continue;
                        }
                        
                        // Skip if it's a number cell (but not start or end)
                        const cellValue = grid[nx][ny];
                        const isNumberCell = cellValue > 0 || Math.abs(cellValue) > tolerance;
                        if (isNumberCell && (nx !== start[0] || ny !== start[1]) && (nx !== end[0] || ny !== end[1])) {
                            continue;
                        }
                        
                        // Note: We allow revisiting nodes in different path contexts
                        // to find multiple distinct paths
                        
                        const newVisited = new Set(visited);
                        newVisited.add(nextKey);
                        queue.push([[nx, ny], [...path, [nx, ny]], newVisited, pathLen + 1]);
                    }
                }
                
                // Sort paths by length (shortest first)
                paths.sort((a, b) => a.length - b.length);
                return paths;
            }
            
            function backtrack(pairsToUse, usedCells, paths) {
                // Check if we've used all number cells
                const usedNumberCells = new Set();
                paths.forEach(path => {
                    usedNumberCells.add(`${path[0][0]},${path[0][1]}`);
                    usedNumberCells.add(`${path[path.length - 1][0]},${path[path.length - 1][1]}`);
                });
                
                if (usedNumberCells.size === allNumberCells.length) {
                    return paths;
                }
                
                // Sort pairs by heuristic: shorter paths first (better for early pruning)
                const availablePairs = pairsToUse
                    .filter(pair => {
                        const [start, end] = pair;
                        const startKey = `${start[0]},${start[1]}`;
                        const endKey = `${end[0]},${end[1]}`;
                        return !usedNumberCells.has(startKey) && !usedNumberCells.has(endKey);
                    })
                    .map(pair => ({
                        pair,
                        priority: manhattanDistance(pair[0], pair[1])
                    }))
                    .sort((a, b) => a.priority - b.priority)
                    .map(item => item.pair);
                
                // Try each remaining pair (now sorted by priority)
                for (const pair of availablePairs) {
                    const [start, end] = pair;
                    
                    // Try multiple paths (up to 20) for this pair to find a solution
                    // This helps find solutions when the first path doesn't work
                    const pathsForPair = findAllPathsBFS(n, grid, start, end, usedCells, 20);
                    
                    for (const path of pathsForPair) {
                        // Add path cells (excluding start and end) to used_cells
                        const newUsedCells = new Set(usedCells);
                        for (let i = 1; i < path.length - 1; i++) {
                            newUsedCells.add(`${path[i][0]},${path[i][1]}`);
                        }
                        
                        // Recursively try to complete the solution
                        const remainingPairs = pairsToUse.filter(p => 
                            !(p[0][0] === pair[0][0] && p[0][1] === pair[0][1] && 
                              p[1][0] === pair[1][0] && p[1][1] === pair[1][1])
                        );
                        const result = backtrack(remainingPairs, newUsedCells, [...paths, path]);
                        
                        if (result !== null) {
                            return result;
                        }
                    }
                }
                
                return null;
            }
            
            // Generate all possible perfect matchings
            function generateMatchings(cells, currentMatching, matchings) {
                if (cells.length === 0) {
                    matchings.push([...currentMatching]);
                    return;
                }
                
                if (cells.length < 2) {
                    return;
                }
                
                const first = cells[0];
                for (let i = 1; i < cells.length; i++) {
                    const second = cells[i];
                    // Use optimized pair check
                    if (isValidPair(first, second)) {
                        const pair = getPair(first, second);
                        if (pair) {
                            const remaining = [...cells.slice(1, i), ...cells.slice(i + 1)];
                            currentMatching.push(pair);
                            generateMatchings(remaining, currentMatching, matchings);
                            currentMatching.pop();
                        }
                    }
                }
            }
            
            const allMatchings = [];
            generateMatchings(allNumberCells, [], allMatchings);
            
            // Sort matchings by total Manhattan distance (try easier ones first)
            const matchingsWithDistance = allMatchings.map(matching => ({
                matching,
                totalDistance: matching.reduce((sum, pair) => 
                    sum + manhattanDistance(pair[0], pair[1]), 0)
            })).sort((a, b) => a.totalDistance - b.totalDistance);
            
            // Try each matching to find valid paths (sorted by difficulty)
            for (const { matching } of matchingsWithDistance) {
                const result = backtrack(matching, new Set(), []);
                if (result !== null) {
                    return result;
                }
            }
            
            return [];
        }

        // Initialize with default grid
        window.addEventListener('DOMContentLoaded', () => {
            createGrid();
        });
    </script>
</body>
</html>
